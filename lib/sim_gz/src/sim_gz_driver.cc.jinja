#include <atomic>
#include <chrono>
#include <csignal>
#include <cmath>
#include <cassert>
#include <iostream>
#include <string>
#include <thread>
#include <gz/msgs.hh>
#include <gz/transport.hh>

#include "../sim_core/src/sim_core.h"
{%- set vehicle = hcdf.vehicle -%}
{%- set simulation = vehicle.simulation -%}
{%- set mcu = vehicle.mcu -%}
{%- set actuators = mcu.actuators -%}
{%- set inputs = mcu.inputs -%}
{%- set model = simulation.model_name.strip('"').strip("'") -%}
{%- set world = simulation.world_name.strip('"').strip("'") -%}

{%- if actuators.escs %}
{% set escs = actuators.escs %}
{%- if vehicle.type == "rover" %}
{% if not escs.esc.__class__.__name__ == 'list' -%}
{% set esc = escs.esc %}
static std::weak_ptr<gz::transport::Node::Publisher> pub_esc{{ esc.control_index }}_ptr{};
static gz::msgs::Double esc{{ esc.control_index }};
static const std::string esc{{ esc.control_index }}_topic = "/model/{{ model }}/{{ esc.sim_topic.strip('"').strip("'") }}";
{% endif -%}
{% if escs.esc.__class__.__name__ == 'list' -%}
{% for esc in escs.esc -%}
static std::weak_ptr<gz::transport::Node::Publisher> pub_esc{{ esc.control_index }}_ptr{};
static gz::msgs::Double esc{{ esc.control_index }};
static const std::string esc{{ esc.control_index }}_topic = "/model/{{ model }}/{{ esc.sim_topic.strip('"').strip("'") }}";
{% endfor -%}
{% endif -%}
{% endif -%}
{%- if vehicle.type == "multicopter" %}
static std::weak_ptr<gz::transport::Node::Publisher> pub_escs_ptr{};
static gz::msgs::Actuators escs;
static const std::string escs_topic = "/model/{{ model }}/command/motor_speed";
static gz::msgs::Time stamp{};
static gz::msgs::Header header{};
{% endif -%}
{% endif -%}

{%- if actuators.servos %}
{% set servos = actuators.servos %}
{% if not servos.servo.__class__.__name__ == 'list' -%}
{% set servo = servos.servo %}
static std::weak_ptr<gz::transport::Node::Publisher> pub_servo{{ servo.control_index }}_ptr{};
static gz::msgs::Double servo{{ servo.control_index }};
static const std::string servo{{ servo.control_index }}_topic = "/model/{{ model }}/{{ servo.sim_topic.strip('"').strip("'") }}";
{% endif -%}
{% if servos.servo.__class__.__name__ == 'list' -%}
{% for servo in servos.servo -%}
static std::weak_ptr<gz::transport::Node::Publisher> pub_servo{{ servo.control_index }}_ptr{};
static gz::msgs::Double servo{{ servo.control_index }};
static const std::string servo{{ servo.control_index }}_topic = "/model/{{ model }}/{{ servo.sim_topic.strip('"').strip("'") }}";
{% endfor -%}
{% endif -%}
{% endif -%}

static const std::string clock_topic = "/world/{{ world }}/clock";
static const std::string mag_topic = "/world/{{ world }}/model/{{ model }}/link/base_link/sensor/mag_sensor/mag";
static const std::string navsat_topic = "/world/{{ world }}/model/{{ model }}/link/base_link/sensor/navsat_sensor/navsat";
static const std::string alt_topic = "/world/{{ world }}/model/{{ model }}/link/base_link/sensor/altimeter_sensor/altimeter";
static const std::string imu_topic = "/world/{{ world }}/model/{{ model }}/link/base_link/sensor/imu_sensor/imu";
static const std::string odom_topic = "/model/{{ model }}/odometry_with_covariance";

static std::atomic<bool> g_terminatePub(false);
static std::atomic<bool> armed(false);

{%- if inputs.trajectory %}
static const std::string trajectory_topic = "{{ inputs.trajectory.topic }}";
static gz::msgs::BezierTrajectory trajectory{};
{% endif -%}

{%- if inputs.manual %}
static gz::msgs::Joy joy{};
static const std::string rc_input_topic = "{{ inputs.manual.topic }}";
{%- endif %}

void imu_callback(const gz::msgs::IMU &msg) {
    uint64_t timestamp = msg.header().stamp().sec()*1e9 + msg.header().stamp().nsec();
    msg_gyroscope_t msg_gyro{
        .timestamp=timestamp,
        .x=msg.angular_velocity().x(),
        .y=msg.angular_velocity().y(),
        .z=msg.angular_velocity().z()
    };
    queue_gyroscope.push(msg_gyro);

    msg_accelerometer_t msg_acc{
        .timestamp=timestamp,
        .x=msg.linear_acceleration().x(),
        .y=msg.linear_acceleration().y(),
        .z=msg.linear_acceleration().z()
    };
    queue_accelerometer.push(msg_acc);
}

void mag_callback(const gz::msgs::Magnetometer &msg) {
    uint64_t timestamp = msg.header().stamp().sec()*1e9 + msg.header().stamp().nsec();
    msg_magnetometer_t msg_pub {
        .timestamp=timestamp,
        .x=msg.field_tesla().x(),
        .y=msg.field_tesla().y(),
        .z=msg.field_tesla().z()
    };
    queue_magnetometer.push(msg_pub);
}

void navsat_callback(const gz::msgs::NavSat &msg) {
    uint64_t timestamp = msg.header().stamp().sec()*1e9 + msg.header().stamp().nsec();
    msg_navsat_t msg_pub{
        .timestamp=timestamp,
        .latitude_deg=msg.latitude_deg(),
        .longitude_deg=msg.longitude_deg(),
        .altitude=msg.altitude(),
        .velocity_east=msg.velocity_east(),
        .velocity_north=msg.velocity_north(),
        .velocity_up=msg.velocity_up()
    };
    queue_navsat.push(msg_pub);
}

void alt_callback(const gz::msgs::Altimeter &msg) {
    uint64_t timestamp = msg.header().stamp().sec()*1e9 + msg.header().stamp().nsec();
    msg_altimeter_t msg_pub {
        .timestamp=timestamp,
        .position=msg.vertical_position(),
        .reference=msg.vertical_reference(),
        .velocity=msg.vertical_velocity()
    };
    queue_altimeter.push(msg_pub);
}

void odom_callback(const gz::msgs::OdometryWithCovariance &msg) {
    uint64_t timestamp = msg.header().stamp().sec()*1e9 + msg.header().stamp().nsec();
    msg_odometry_t msg_odom{
        .timestamp=timestamp,
        .x=msg.pose_with_covariance().pose().position().x(),
        .y=msg.pose_with_covariance().pose().position().y(),
        .z=msg.pose_with_covariance().pose().position().z(),
        .qx=msg.pose_with_covariance().pose().orientation().x(),
        .qy=msg.pose_with_covariance().pose().orientation().y(),
        .qz=msg.pose_with_covariance().pose().orientation().z(),
        .qw=msg.pose_with_covariance().pose().orientation().w(),
        .vx=msg.twist_with_covariance().twist().linear().x(),
        .vy=msg.twist_with_covariance().twist().linear().y(),
        .vz=msg.twist_with_covariance().twist().linear().z(),
        .wx=msg.twist_with_covariance().twist().angular().x(),
        .wy=msg.twist_with_covariance().twist().angular().y(),
        .wz=msg.twist_with_covariance().twist().angular().z()
    };
    queue_external_odometry.push(msg_odom);
}

{% if inputs.trajectory %}
void trajectory_callback(const gz::msgs::BezierTrajectory &msg) {
    uint64_t timestamp = msg.header().stamp().sec()*1e9 + msg.header().stamp().nsec();
    msg_trajectory_t msg_trajectory{
        .timestamp=timestamp,
        .sequence=uint16_t(msg.sequence()),
        .time_start=msg.time_start(),
        .time_stop=msg.time_stop(),
        .x={},
        .y={},
        .z={},
        .yaw={}
    };
    for (int m = 0; m < msg.x_size(); m++) {
        msg_trajectory.x[m]=msg.x()[m];
    };
    for (int m = 0; m < msg.y_size(); m++) {
        msg_trajectory.y[m]=msg.y()[m];
    };
    for (int m = 0; m < msg.z_size(); m++) {
        msg_trajectory.z[m]=msg.z()[m];
    };
    for (int m = 0; m < msg.yaw_size(); m++) {
        msg_trajectory.yaw[m]=msg.yaw()[m];
    };
    queue_trajectory.push(msg_trajectory);
}
{% endif %}
{% if inputs.manual %}
{%- set buttons = inputs.manual.buttons -%}
{%- set axes = inputs.manual.axes -%}
void rc_input_callback(const gz::msgs::Joy &msg) {
    uint64_t timestamp = msg.header().stamp().sec()*1e9 + msg.header().stamp().nsec();
    if (!armed && msg.buttons()[{{ buttons.arm }}] == 1) {
        armed = true;
        std::cout << "armed!" << std::endl;
    }
    if (armed && msg.buttons()[{{ buttons.disarm }}] == 1) {
        armed = false;
        std::cout << "dis-armed!" << std::endl;
    }
    msg_rc_input_t msg_rc_input{
        .timestamp=timestamp,
    {%- if axes.roll %}
        .roll=-(msg.axes()[{{ axes.roll }}]),
    {%- endif %}
    {%- if axes.pitch %}
        .pitch=msg.axes()[{{ axes.pitch }}],
    {%- endif %}
    {%- if axes.yaw %}
        .yaw=msg.axes()[{{ axes.yaw }}],
    {%- endif %}
    {%- if axes.thrust %}
        .thrust=msg.axes()[{{ axes.thrust }}],
    {%- endif %}
    {%- if buttons.mode %}
        .mode=control_mode_t(msg.buttons()[{{ buttons.mode }}]),
    {%- endif %}
        .armed=armed,
    };
    queue_rc_input.push(msg_rc_input);
}
{% endif %}

void clock_callback(const gz::msgs::Clock &msg) {
    sim_time_t msg_pub {
        .sec=msg.sim().sec(),
        .nsec=msg.sim().nsec()
    };
    queue_sim_time.push(msg_pub);
}

void thread_sim_entry_point(void)
{
    // Create a transport node and advertise a topic.
    gz::transport::Node node;

{%- if actuators.escs %}
{%- if vehicle.type == "multicopter" %}
    // prepare messages, must occur before control sent (subscriber launched)
    header.set_allocated_stamp(&stamp);
    {% for esc in escs.esc -%}
    escs.add_velocity(0);
    {% endfor -%}
    escs.set_allocated_header(&header);

    auto pub_escs = std::make_shared<gz::transport::Node::Publisher>(
        node.Advertise<gz::msgs::Actuators>(escs_topic));
    if (!pub_escs)
    {
        std::cerr << "Error advertising topic [" << escs_topic << "]" << std::endl;
        return;
    }
    pub_escs_ptr = pub_escs;
{% endif %}
{%- if vehicle.type == "rover" %}
{% if not escs.esc.__class__.__name__ == 'list' -%}
{%- set esc = escs.esc %}
    auto pub_esc{{ esc.control_index }} = std::make_shared<gz::transport::Node::Publisher>(
        node.Advertise<gz::msgs::Double>(esc{{ esc.control_index }}_topic));
    if (!pub_esc{{ esc.control_index }})
    {
        std::cerr << "Error advertising topic [" << esc{{ esc.control_index }}_topic << "]" << std::endl;
        return;
    }
    pub_esc{{ esc.control_index }}_ptr = pub_esc{{ esc.control_index }};
{% endif -%}
{% if escs.esc.__class__.__name__ == 'list' -%}
{%- for esc in escs.esc %}
    auto pub_esc{{ esc.control_index }} = std::make_shared<gz::transport::Node::Publisher>(
        node.Advertise<gz::msgs::Double>(esc{{ esc.control_index }}_topic));
    if (!pub_esc{{ esc.control_index }})
    {
        std::cerr << "Error advertising topic [" << esc{{ esc.control_index }}_topic << "]" << std::endl;
        return;
    }
    pub_esc{{ esc.control_index }}_ptr = pub_esc{{ esc.control_index }};
{% endfor %}
{% endif -%}
{% endif %}
{% endif %}
{%- if actuators.servos %}
{% if not servos.servo.__class__.__name__ == 'list' -%}
{%- set servo = servos.servo %}
    auto pub_servo{{ servo.control_index }} = std::make_shared<gz::transport::Node::Publisher>(
        node.Advertise<gz::msgs::Double>(servo{{ servo.control_index }}_topic));
    if (!pub_servo{{ servo.control_index }})
    {
        std::cerr << "Error advertising topic [" << servo{{ servo.control_index }}_topic << "]" << std::endl;
        return;
    }
    pub_servo{{ servo.control_index }}_ptr = pub_servo{{ servo.control_index }};
{% endif %}
{% if servos.servo.__class__.__name__ == 'list' -%}
{%- for servo in servos.servo %}
    auto pub_servo{{ servo.control_index }} = std::make_shared<gz::transport::Node::Publisher>(
        node.Advertise<gz::msgs::Double>(servo{{ servo.control_index }}_topic));
    if (!pub_servo{{ servo.control_index }})
    {
        std::cerr << "Error advertising topic [" << servo{{ servo.control_index }}_topic << "]" << std::endl;
        return;
    }
    pub_servo{{ servo.control_index }}_ptr = pub_servo{{ servo.control_index }};
{% endfor %}
{% endif %}
{% endif %}
    // imu sub
    bool sub_imu = node.Subscribe<gz::msgs::IMU>(imu_topic, imu_callback);
    if (!sub_imu)
    {
        std::cerr << "Error subscribing to topic [" << imu_topic << "]" << std::endl;
        return;
    }

    // odom sub
    bool sub_odom = node.Subscribe<gz::msgs::OdometryWithCovariance>(odom_topic, odom_callback);
    if (!sub_odom)
    {
        std::cerr << "Error subscribing to topic [" << odom_topic << "]" << std::endl;
        return;
    }

    // clock sub
    bool sub_clock = node.Subscribe<gz::msgs::Clock>(clock_topic, clock_callback);
    if (!sub_clock)
    {
        std::cerr << "Error subscribing to topic [" << clock_topic << "]" << std::endl;
        return;
    }

    // mag sub
    bool sub_mag = node.Subscribe<gz::msgs::Magnetometer>(mag_topic, mag_callback);
    if (!sub_mag)
    {
        std::cerr << "Error subscribing to topic [" << mag_topic << "]" << std::endl;
        return;
    }

    // navsat sub
    bool sub_navsat = node.Subscribe<gz::msgs::NavSat>(navsat_topic, navsat_callback);
    if (!sub_navsat)
    {
        std::cerr << "Error subscribing to topic [" << navsat_topic << "]" << std::endl;
        return;
    }

    // altimeter sub
    bool sub_alt = node.Subscribe<gz::msgs::Altimeter>(alt_topic, alt_callback);
    if (!sub_alt)
    {
        std::cerr << "Error subscribing to topic [" << alt_topic << "]" << std::endl;
        return;
    }
{% if inputs.trajectory %}
    // Trajectory sub
    bool sub_trajectory = node.Subscribe<gz::msgs::BezierTrajectory>(trajectory_topic, trajectory_callback);
    if (!sub_trajectory)
    {
        std::cerr << "Error subscribing to topic [" << trajectory_topic << "]" << std::endl;
        return;
    }
{% endif %}
{% if inputs.manual %}
    // rc_input sub
    bool sub_rc_input = node.Subscribe<gz::msgs::Joy>(rc_input_topic, rc_input_callback);
    if (!sub_rc_input)
    {
        std::cerr << "Error subscribing to topic [" << rc_input_topic << "]" << std::endl;
        return;
    }
{% endif %}
    // actuator msg
    msg_actuators_t msg;

    // sleep main thread, everything done async
    while (!g_terminatePub)
    {
        // host sleep doesn't count for zephyr time
        while (queue_actuator.tryPop(msg)) {
            uint64_t sec = msg.timestamp/1e9;
            uint64_t nsec = msg.timestamp - sec*1e9;

{%- if actuators.escs %}
{%- if vehicle.type == "multicopter" %}
            escs.set_velocity({{ esc.sim_actuator }}, msg.actuator{{ esc.control_index }}_value);
            if (!pub_esc_ptr.lock().get()->Publish(escs)) {
                std::cerr << "Error publishing topic [" << esc_topic << "]" << std::endl;
            }

{% endif %}
{%- if vehicle.type == "rover" %}
{% if not escs.esc.__class__.__name__ == 'list' -%}
{% set esc = escs.esc %}
            esc{{ esc.control_index }}.set_data(msg.actuator{{esc.control_index }}_value);
            esc{{ esc.control_index }}.mutable_header()->mutable_stamp()->set_sec(sec);
            esc{{ esc.control_index }}.mutable_header()->mutable_stamp()->set_nsec(nsec);
            if (!pub_esc{{ esc.control_index }}_ptr.lock().get()->Publish(esc{{ esc.control_index }})) {
                std::cerr << "Error publishing topic [" << esc{{ esc.control_index }}_topic << "]" << std::endl;
            }
{% endif -%}
{% if escs.esc.__class__.__name__ == 'list' -%}
{%- for esc in escs.esc %}
            esc{{ esc.control_index }}.set_data(msg.actuator{{esc.control_index }}_value);
            esc{{ esc.control_index }}.mutable_header()->mutable_stamp()->set_sec(sec);
            esc{{ esc.control_index }}.mutable_header()->mutable_stamp()->set_nsec(nsec);
            if (!pub_esc{{ esc.control_index }}_ptr.lock().get()->Publish(esc{{ esc.control_index }})) {
                std::cerr << "Error publishing topic [" << esc{{ esc.control_index }}_topic << "]" << std::endl;
            }

{%- endfor -%}
{% endif %}
{% endif %}
{% endif -%}
{%- if actuators.servos %}
{% if not servos.servo.__class__.__name__ == 'list' -%}
{% set servo = servos.servo %}
            servo{{ servo.control_index }}.set_data(msg.actuator{{servo.control_index }}_value);
            servo{{ servo.control_index }}.mutable_header()->mutable_stamp()->set_sec(sec);
            servo{{ servo.control_index }}.mutable_header()->mutable_stamp()->set_nsec(nsec);
            if (!pub_servo{{ servo.control_index }}_ptr.lock().get()->Publish(servo{{ servo.control_index }})) {
                std::cerr << "Error publishing topic [" << servo{{ servo.control_index }}_topic << "]" << std::endl;
            }
{% endif %}
{% if servos.servo.__class__.__name__ == 'list' -%}
{%- for servo in servos.servo %}
            servo{{ servo.control_index }}.set_data(msg.actuator{{servo.control_index }}_value);
            servo{{ servo.control_index }}.mutable_header()->mutable_stamp()->set_sec(sec);
            servo{{ servo.control_index }}.mutable_header()->mutable_stamp()->set_nsec(nsec);
            if (!pub_servo{{ servo.control_index }}_ptr.lock().get()->Publish(servo{{ servo.control_index }})) {
                std::cerr << "Error publishing topic [" << servo{{ servo.control_index }}_topic << "]" << std::endl;
            }

{%- endfor -%}
{% endif -%}
{% endif %}
            // sleep 1 ms
            usleep(1000);
        }
    }
}

std::thread th_sim_gz_driver(thread_sim_entry_point);
