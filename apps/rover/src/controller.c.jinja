#include <zephyr/kernel.h>
#include <math.h>

#include "channels.h"
#include <stdio.h>

float gx = 0;
float gy = 0;
float gz = 0;


{%- set vehicle = hcdf.vehicle -%}
{%- set mcu = vehicle.mcu -%}
{%- set actuators = mcu.actuators -%}
{%- set inputs = mcu.inputs -%}
{%- if actuators.servos -%}
{% set servos = actuators.servos %}
{% endif %} 
{% set escs = actuators.escs %}
{%- set mixer = actuators.mixer -%}

void listener_controller_callback(const struct zbus_channel *chan) {
    
    if (chan == &chan_rc_input) {
        const struct msg_rc_input_t *msg_rc_input = (const struct msg_rc_input_t *)zbus_chan_const_msg(chan);
        struct msg_actuators_t actuators_msg;
{%- if inputs.manual.axes.thrust %}
        double vt = msg_rc_input->thrust;
{% endif %}
{%- if inputs.manual.axes.roll %}
        double vr = msg_rc_input->roll;
{% endif %}
{%- if inputs.manual.axes.pitch %}
        double vp = msg_rc_input->pitch;
{% endif %}
{%- if inputs.manual.axes.yaw %}
        double vy = msg_rc_input->yaw;
{% endif %}  
        bool armed = msg_rc_input->armed;
      
{% if ( mixer.type == "ackermann") %}
        double mix_thrust = armed ? vt : 0;
        double mix_yaw = armed ? vy : 0;
{%- set yaw = mixer.yaw.split(',') -%}
{% set thrust = mixer.thrust.split(',') %}
    {% for name, esc in escs.items()  %}
        double scale{{ esc.control_index }} = ({{ esc.max_rps }} - {{ esc.min_rps }}) / 2.0;
        double actuator{{ esc.control_index }} = {{ thrust[esc.control_index | int ] }}*mix_thrust*scale{{ esc.control_index }} + {{ yaw[esc.control_index | int ] }}*mix_yaw*scale{{ esc.control_index }};
        if(actuator{{ esc.control_index }} > {{ esc.max_rps }}) {
            actuator{{ esc.control_index }} = {{ esc.max_rps }};
        } else if (actuator{{ esc.control_index }} < {{ esc.min_rps }}) {
            actuator{{ esc.control_index }} = {{ esc.min_rps }};
        }
        actuators_msg.actuator{{ esc.control_index }}_value = actuator{{ esc.control_index }};
    {% endfor %}
    {% for name, servo in servos.items()  %}
        double scale{{ servo.control_index }} = ({{ servo.max }} - {{ servo.min }}) / 2.0;
        double actuator{{ servo.control_index }} = {{ thrust[servo.control_index | int ] }}*mix_thrust*scale{{ servo.control_index }} + {{ yaw[servo.control_index | int ] }}*mix_yaw*scale{{ servo.control_index }};
        if(actuator{{ servo.control_index }} > {{ servo.max }}) {
            actuator{{servo.control_index }} = {{ servo.max }};
        } else if (actuator{{ servo.control_index }} < {{ servo.min }}) {
            actuator{{ servo.control_index }} = {{ servo.min }};
        }
        actuators_msg.actuator{{ servo.control_index }}_value = actuator{{ servo.control_index }};
    {% endfor %}
{%- endif %}

        zbus_chan_pub(&chan_actuators, &actuators_msg, K_NO_WAIT);

    } else if (chan == &chan_gyroscope) {
        const struct msg_gyroscope_t * msg_gyroscope = (const struct msg_gyroscope_t *)zbus_chan_const_msg(chan);
        gx = msg_gyroscope->x;
        gy = msg_gyroscope->y;
        gz = msg_gyroscope->z;
    }
}
ZBUS_LISTENER_DEFINE(listener_controller, listener_controller_callback);

